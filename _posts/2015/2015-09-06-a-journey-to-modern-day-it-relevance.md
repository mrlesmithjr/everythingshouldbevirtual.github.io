---
  title: A Journey to modern-day IT relevance
---

We keep hearing this term day in and day out it seems. Attending
conferences, meet-ups and other social events keep pushing this down our
throats in one way or another. So what exactly are they trying to tell
us and how do I take what is being said and put it to use in my world?
Well I want to take you on a journey throughout my career and hope to
make some sense out of all of this. Also I encourage feedback to help
others understand the philosophy and ideas but also to help me grow as
well. After all, when I hear what is being preached it totally makes
sense to me and I take this for granted and sometimes fail to realize
that not everyone sees things the same way.

## Early Early Days

I want to start out by putting some context around my age to hopefully
set my perspective on all of this. No I am not old and no I am not
young. I am 43 years old at the time of this writing. I like many others
were raised during a time when computers and coding were not mainstream
and were definitely not cool at all. I was a sports jock (Football and
Baseball). I lived and breathed sports. I had a great opportunity that
laid in front of me to be a future potential professional baseball
player. However after many knee injuries and ACL replacements those
dreams dwindled away rather quickly. With this being said I actually had
another passion that not many people around me knew of. It was the fact
that I loved writing code. I began writing code
([BASIC](https://en.wikibooks.org/wiki/BASIC_Programming)) when I was
about 13 on a [TRS-80](https://en.wikipedia.org/wiki/TRS-80)
('Trash-80'). My father would bring me home copies of [Rainbow magazine](https://en.wikipedia.org/wiki/The_Rainbow_(magazine)) and I
would copy line for line the code and of course over time began creating
my own code to do many different things. What I learned from all of this
is that I honestly wanted a career which would be rather easy and
rewarding at the same time (Most people do right?). So as I grew from
around 13 years old until I graduated from high school in 1990 I had it
in the back of my head that I wanted to go onto college for computer
programming. Fast forward to around 1991 after taking a bit of time off
between high school and college I began my journey into college to
become a hardcore coder. I began writing
[Assembler](https://en.wikipedia.org/wiki/Assembly_language) code on a
[VAX](https://en.wikipedia.org/wiki/VAX) system and absolutely loved
being at the lowest of low in a computer system. Getting your mind to
function from right to left vs. normal left to right was the biggest
hurdle to overcome but it definitely helped in getting my mind to think
differently. I then moved onto [Quick BASIC](https://en.wikipedia.org/wiki/QuickBASIC)
(No line numbers and loops :), [C](https://en.wikipedia.org/wiki/C_(programming_language)),
[C++](https://en.wikibooks.org/wiki/C%2B%2B_Programming),
[DBase](https://en.wikipedia.org/wiki/DBase) and then dabbled in
FORTRAN, PASCAL and RPG. I remember the day when sitting with some
classmates and saying "Man, wouldn't it be awesome if there was a UNIX
that could be running on our PC's at home and not have to spend all of
our time in the labs at college?". We knew about
[MINIX](https://en.wikipedia.org/wiki/MINIX) but it was not free or
open. Well that turned into a few of us getting together and beginning
to design out what was going to be our own OS written from scratch.
After spending some time kicking around all of these ideas and putting
some code around these ideas I soon realized the toll that being a coder
was putting on my day-to-day life. I did not want to be this man behind
a door without a life and not be able to have a normal conversation with
others. So I began to back off and I eventually dropped out of college
and stopped writing code. I began to level set where I was and where I
wanted to go in life with computers still being a focus (Remember, an
easy and rewarding career was my goal). So I took a break for a while.

## Early Days

Next I began my journey down the road of becoming more of an
admin/engineer. I finally landed what would be my first IT gig around 1993.

I was working for a company who built Ham Radios (I have no idea
on how to even use one). My role there was to take prototypes, design
them out in AutoCad by using a micrometer and bend calculations based on
the type of metal being used, draw them in AutoCad and then produce a
punch disk to take down to an assembly line in where they would stamp
out what I had drawn out. Finding this pretty cool to actually take
something that I had drawn out and see the final product was rather
rewarding to me. But I wanted more. It was at this same job that I had
the opportunity to also begin learning some [Novell Netware](https://en.wikipedia.org/wiki/NetWare) 3.x and basic networking. This is when I really began realizing how much I really
liked making all of these different devices on a network to talk to one
another. I then moved onto learning [Windows For WorkGroups 3.1x](https://en.wikipedia.org/wiki/Windows_3.1x) and then [Windows NT 3.1](https://en.wikipedia.org/wiki/Windows_NT_3.1) during this time as
well. All of this learning of course helped me land my next gig. Which
was where I continued to learn additional networking as well as
Microsoft Exchange and cloning out machines from Iomega Jaz drives. :)
In 1995 I finally was also treated with my first home copy of Linux,
[Slackware](https://en.wikipedia.org/wiki/Slackware) 3.x, oh the joy of
loading up 30+ floppy drives and installing the whole OS from these only
to find out that it didn't really work! But that was fine by me being
that I enjoyed being able to reverse engineer something and begin to
learn how to make things work when they didn't from the start. And this
began my Linux journey to 20 years later of everyday using Linux. Now
keep in mind I also equally kept and keep learning all Windows versions
inside and out along the way as well. So over the next few years I
continued learning Linux, Windows and every other OS I could get my
hands on. And finally I was exposed to Cisco networking around 1998. I
was lucky enough to have a colleague who would spend countless hours
helping me learn network routing and switching and eventually firewalls
as well. Did I learn it completely? Absolutely not. However, I did learn
it enough to add it to my growing knowledge of how things begin to come
together. This also lead me to other learning experiences of hacking and
learning how vulnerabilities were exposed and utilized. Then in 1999 I
was handed a copy of this thing called VMware Workstation 1.0 and I
thought to myself "this is the coolest thing ever" until I got my
hands on early [VMware ESX](https://en.wikipedia.org/wiki/VMware_ESX),
[VMware GSX](https://en.wikipedia.org/wiki/VMware_Server) and so on. And
it was these products that began my journey from an admin into more of
an architecture type role over the years. As I began learning more and
more about networking, storage and compute I continued to look back and
question myself about where I would be if I were to still be a coder.
This also discouraged me as well, because I still wanted to not live in
this little box writing code. So I would over the next 10+ years
continue to learn a new technology each and every week reaching way out
of my comfort zone as much as possible. All of the time always trying to
look ahead and see how each additional thing that I learned could be
used in conjunction with the previous things that I had already learned.
Again, never being an expert but understanding the philosophy and
purpose that each thing would/could serve. What I really did not realize
is that in some sort of sense I was beginning a different type of
development mindset. Instead of writing code, I was figuring out more
and more all of the time on how to take all of these different
technologies and tie them together to make this bigger thing. Sure, you
could spend a ton of money on these solutions but why would I? I could
take many of these open source projects and make them function in a very
elaborate way, and each different thing I would learn leant itself to
the next.

## Recent Days

So as time went on and I would say the past 4 years are in mind here. I
began to realize for myself that what was driving me day to day from an
infrastructure architect type role was starting to get dry for me. All
of the years that I had been using Linux it was still amazing to me that
it was very seldom where you could find online a blog post or anything
that could truly step you through from beginning to end a fully working
open source product. It was then that I began a different journey. I
wanted to take the countless hours that I would spend in making a
solution work and put it into either a complete blog post and/or a
corresponding shell script. That a normal person could take and go from
start to finish and have a workable solution with very little
interaction along the way. Again, another form of developing
(Automation, not coding). It was during this time that I also realized
that it would be time again soon that writing code would be crucial in
my future development. And during this time as well I discovered
configuration management tools such as Chef, Puppet and Salt. Each time
I would try and take the time to go and learn each of these it always
seemed like a setback to me. It seemed that I would have to take the
time to learn these elaborate tools in which I could easily still do
most of the tasks that I required just writing shell scripts. It was
honestly until I found Ansible where I finally gave up writing shell
scripts and fully dedicated myself to every solution that I put
together, no matter how big or how small it may be into a playbook or
role. Again, the whole time ensuring that I could share this code with
others and they could reproduce an environment easily by changing a few
variables. Another important lesson that I learned during this time of
writing shell scripts and Ansible roles/playbooks was the value of
version control and continuous integration. As I wrote these shell
scripts and Ansible roles/playbooks and committed the code to GIT, I
would leverage Jenkins and/or Travis CI to ensure that all of the code
was successful and if it was not, where was it breaking down and what
changed. It is with these sort of methodologies that I began preaching
the importance of these tools to others. Either for just writing up
installations of apps, elaborate clustered solutions or even just
network configurations. Some are believers and then some are not of
course. But my hopes are that being able to share my experiences,
methodologies and creating ways for others to learn from will have a
huge impact. The fact that for the majority of people do not even know
how to get started has become more apparent over the past few months. By
being involved in conferences and other social gatherings what seems
logical to myself seems rather far fetched for others. Or the simple
fact is that they do not even know how to get started on learning some
of these tools.

## Current/Future Days

My goal as of now and going forward is to take many of these
methodologies and technologies and put them into a consumable format for
others to begin learning (ex.
[here](https://everythingshouldbevirtual.com/learning-vagrant-and-ansible-provisioning)).
Maybe someone just wants to learn Ansible for automation but maybe
another may want to learn the same but have the ability to test out a
network design using different routing protocols while using the exact
IP scheme which is being used in production and not have to worry about
breaking production. I will be leveraging Vagrant from an ease of
defining an environment virtually on your laptop and tying in Ansible
along with whatever solution you may be putting together. In doing this
I believe that this along with a corresponding blog post will help
others to go from ground up and beginning to understand the things that
can keep your relevance in IT. Although one may argue that being a
virtualization person is good enough, I would argue against that and say
that knowing virtualization is only one piece of the puzzle for one to
know. Virtualization is like an OS in my opinion. It is purely a
building block to a bigger solution. I know I sound like others
spreading FUD at events but it is honestly the truth. I heard a great
panel discussion that was stressing the importance of taking an admin
and turning them into a developer and on the flip side taking a
developer and turning them into an admin. This may seem rather fictional
to some but it is very much true. You do not have to be an expert on any
one thing, however; being able to have an intelligent broad discussion
across all elements is key. No matter if it is code, application design,
infrastructure or administration. Having the ability to understand each
element is absolutely crucial. So I absolutely encourage everyone to get
outside of your element and learn and share. And hopefully this does not
sound like all of the FUD you hear day in and day out. But I find myself
being living proof of what is continually being talked about. And oh, by
the way, I have began writing or hacking a bit of code as of late as
well. However, I plan on writing a lot of code coming soon. I think for
me personally it was a maturity lesson or maybe just a venture of
learning what all else goes on outside of code.

Enjoy!
