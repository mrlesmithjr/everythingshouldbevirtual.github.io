---
layout: post
title: Homebrew NAS for vSphere
date: 2014-12-15 15:17:01.000000000 -05:00
type: post
published: true
status: publish
categories:
- Storage
- Virtualization
- VMware
tags:
- esxi
- iSCSI
- NAS
- NFS
- samba
- ubuntu
- Vsphere
- ZFS
meta:
  _edit_last: '11'
  snap_MYURL: ''
  snapEdIT: '1'
  snapFB: s:280:"a:1:{i:0;a:9:{s:4:"doFB";s:1:"1";s:8:"postType";s:1:"A";s:10:"AttachPost";s:1:"1";s:10:"SNAPformat";s:51:"New
    post (%TITLE%) has been published on %SITENAME%";s:9:"isAutoImg";s:1:"A";s:8:"imgToUse";s:0:"";s:9:"isAutoURL";s:1:"A";s:8:"urlToUse";s:0:"";s:11:"isPrePosted";s:1:"1";}}";
  snapLI: s:274:"a:1:{i:0;a:9:{s:4:"doLI";s:1:"1";s:10:"AttachPost";s:1:"1";s:10:"SNAPformat";s:41:"New
    post has been published on %SITENAME%";s:11:"SNAPformatT";s:1:" ";s:9:"isAutoImg";s:1:"A";s:8:"imgToUse";s:0:"";s:9:"isAutoURL";s:1:"A";s:8:"urlToUse";s:0:"";s:11:"isPrePosted";s:1:"1";}}";
  _s2mail: 'yes'
  _yoast_wpseo_focuskw: Homebrew NAS for vSphere
  _yoast_wpseo_metadesc: Homebrew NAS for vSphere
  _yoast_wpseo_linkdex: '79'
  snap_isAutoPosted: '1'
  snapDL: s:242:"a:1:{i:0;a:7:{s:4:"doDL";s:1:"1";s:11:"SNAPformatT";s:7:"%TITLE%";s:10:"SNAPformat";s:9:"%EXCERPT%";s:11:"isPrePosted";s:1:"1";s:8:"isPosted";s:1:"1";s:4:"pgID";s:32:"0698d57b1b4d615052f63b358061de82";s:5:"pDate";s:19:"2014-12-15
    20:17:03";}}";
  snapSU: s:304:"a:1:{i:0;a:9:{s:4:"doSU";s:1:"1";s:7:"apSUCat";s:2:"IT";s:4:"nsfw";s:1:"0";s:10:"SNAPformat";s:16:"%TITLE%
    - %TEXT%";s:11:"isPrePosted";s:1:"1";s:8:"isPosted";s:1:"1";s:4:"pgID";s:6:"5MQp8j";s:7:"postURL";s:50:"http://www.stumbleupon.com/content/5MQp8j/comments";s:5:"pDate";s:19:"2014-12-15
    20:17:15";}}";
  snapTW: 's:320:"a:1:{i:0;a:9:{s:4:"doTW";s:1:"1";s:10:"SNAPformat";s:64:"%TITLE%
    - %URL% #everythingshouldbevirtual #ubuntu #vsphere #nas";s:8:"attchImg";s:1:"0";s:9:"isAutoImg";s:1:"A";s:8:"imgToUse";s:0:"";s:11:"isPrePosted";s:1:"1";s:8:"isPosted";s:1:"1";s:4:"pgID";s:18:"544587012347793410";s:5:"pDate";s:19:"2014-12-15
    20:17:16";}}";'
  _wp_rp_related_posts_query_result_cache_expiration: '1511247252'
  dsq_thread_id: '3346727039'
  _wp_rp_related_posts_query_result_cache_6: a:12:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:2:"41";s:5:"score";s:17:"153.8781523222181";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:2:"98";s:5:"score";s:18:"152.92353877256716";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"909";s:5:"score";s:18:"149.12156736571322";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:4:"7243";s:5:"score";s:18:"100.81836074805886";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:3:"755";s:5:"score";s:17:"98.21928451715854";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:3:"699";s:5:"score";s:17:"92.95737556941191";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:4:"1494";s:5:"score";s:16:"82.9310629439506";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:3:"199";s:5:"score";s:17:"78.17976235753457";}i:8;O:8:"stdClass":2:{s:7:"post_id";s:4:"1016";s:5:"score";s:16:"77.8317699677998";}i:9;O:8:"stdClass":2:{s:7:"post_id";s:3:"887";s:5:"score";s:17:"77.11262035855421";}i:10;O:8:"stdClass":2:{s:7:"post_id";s:3:"522";s:5:"score";s:17:"71.62085089923637";}i:11;O:8:"stdClass":2:{s:7:"post_id";s:4:"2307";s:5:"score";s:17:"68.43617339445257";}}
  _wp_rp_image: '3897'
author:
  login: larry.e.smith.jr
  email: larry.e.smith.jr@gmail.com
  display_name: mrlesmithjr
  first_name: Larry
  last_name: Smith
---
<h1 style="text-align: center;">Homebrew NAS for vSphere</h1>
<p>So for the past 4 years or so I have been running Nexenta 3.x for my lab NAS; which has been working great, but I was at a point of having to rebuild my latest build to get the new 4.x Nexenta. With that I finally started kicking around some ideas on going a different route instead (knowing that ZFS was still going to be part of the new solution). I have two NAS servers that I have built for Nexenta over the years (<a title="My Home Lab NexentaStor CE NAS" href="http://everythingshouldbevirtual.com/my-home-lab-nexentastor-ce-nas">First build</a> and <a title="New Nexenta Server Coming Soon" href="http://everythingshouldbevirtual.com/new-nexenta-server-coming-soon">second build</a>) so I started on this journey and figured that I would share it with everyone.</p>
<p>I first set out to an idea of running a GlusterFS cluster utilizing both NAS servers. This began to look very promising as I stood up the first node (Ubuntu 14.04LTS) and installed and configured ZFS for Linux (ZOL). ZOL runs currently in userland instead of kernel but I am not too worried about that at this point. So I began storage vMotioning all of my VMs over to it. GlusterFS also includes it's own NFS server to provide access to your vSphere hosts (can still use NFSD but can get a little clunky IMHO). GlusterFS uses what are called bricks; bricks are basically nodes with storage provided to be added to a virtual volume. You can replicate (mirror) these volumes as well as distribute (stripe) and you can also mix the two replicate+distribute. After running just a single node with bricks assigned from itself only it seemed to be a rocking solution with plenty of opportunity. So I then rebuilt my other NAS server (Ubuntu 14.04LTS) then installed and configured ZOL as well as GlusterFS. I peered both nodes and created the cluster. I also planned on using KeepaliveD for VRRP to provide a single VIP as an entry point into the NFS mounts which would be presented from Gluster as well as provide failover for my vSphere NFS datastores. I started with some of the low hanging; not so important VMs and began creating my replication bricks. It was looking great until I started getting some disconnected datastores and eventually a few VMs were crashing. After looking into this after a few times it appeared that what was happening was that the replica bricks were overloading the CPU on the primary node and basically causing an APD (All Paths Down). So I then began to search the internet for a possible solution but in the short time and many late nights trying to figure this out I finally decided to postpone the GlusterFS implementation phase at this point. It does look like other Linux distros may perform better than Ubuntu but I did not want to continue to look into this any further at this time. I did however implement a GlusterFS setup between some Apache web servers to house the web content and synchronize between the nodes and this has been working much better than using unison previously.</p>
<h4>NIC Redundancy</h4>
<p>This being a very critical part of the solution I decided to create a network bond between the two interfaces and create virtual interfaces on top of the bonded ports using VLAN tagging. I chose to go with <a title="https://help.ubuntu.com/community/UbuntuBonding" href="https://help.ubuntu.com/community/UbuntuBonding" target="_blank">ifenslave</a> to accomplish the nic bonding.</p>
<p>First you need to install the actual ifenslave package.</p>
<pre>sudo apt-get install ifenslave-2.6
sudo modprobe bonding</pre>
<p>And for vlan tagging support.</p>
<pre>sudo apt-get install vlan
sudo modprobe 8021q</pre>
<p>Now all you need to do is modify your /etc/network/interfaces to look like below (Change to suit your requirements)</p>
<pre>sudo nano /etc/network/interfaces</pre>
<p>Below is what my setup looks like (I chose balance-alb for my bonding mode)</p>
<pre># This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
#auto p5p1
#iface p5p1 inet dhcp

auto p5p1
iface p5p1 inet manual
bond-master bond0

auto p6p1
iface p6p1 inet manual
bond-master bond0

auto bond0
iface bond0 inet manual
slaves p5p1 p6p1
bond-mode balance-alb
bond-miimon 100

auto vlan101
iface vlan101 inet static
address 10.0.101.50
netmask 255.255.255.0
broadcast 10.0.101.255
up route add default gw 10.0.101.1
dns-search      everythingshouldbevirtual.local
dns-nameservers 10.0.101.110 10.0.101.111 10.0.110.112
vlan-raw-device bond0

auto vlan127
iface vlan127 inet static
address 10.0.127.50
netmask 255.255.255.0
broadcast 10.0.127.255
vlan-raw-device bond0

auto vlan128
iface vlan128 inet static
address 10.0.128.50
netmask 255.255.255.0
broadcast 10.0.128.255
vlan-raw-device bond0

auto vlan129
iface vlan129 inet static
address 10.0.129.50
netmask 255.255.255.0
broadcast 10.0.129.255
vlan-raw-device bond0

auto vlan130
iface vlan130 inet static
address 10.0.130.50
netmask 255.255.255.0
broadcast 10.0.130.255
vlan-raw-device bond0
</pre>
<p>Now let's make some network tweaks to get the best performance we can.</p>
<pre>sudo bash
# Tweak network settings
echo "# reuse TIME-WAIT sockets" &gt;&gt; /etc/sysctl.conf
echo "net.ipv4.tcp_tw_reuse=1" &gt;&gt; /etc/sysctl.conf
echo "# increase max num of ports" &gt;&gt; /etc/sysctl.conf
echo "net.ipv4.ip_local_port_range=1024 65023" &gt;&gt; /etc/sysctl.conf
echo "# increase the number of outstanding syn requests" &gt;&gt; /etc/sysctl.conf
echo "net.ipv4.tcp_max_syn_backlog=40000" &gt;&gt; /etc/sysctl.conf
echo "# maximal number of timewait sockets" &gt;&gt; /etc/sysctl.conf
echo "net.ipv4.tcp_max_tw_buckets=400000" &gt;&gt; /etc/sysctl.conf
echo "net.ipv4.tcp_max_orphans=60000" &gt;&gt; /etc/sysctl.conf
echo "# tcp syn flood protection" &gt;&gt; /etc/sysctl.conf
echo "net.ipv4.tcp_syncookies=1" &gt;&gt; /etc/sysctl.conf
echo "# tcp syn flood protection" &gt;&gt; /etc/sysctl.conf
echo "net.ipv4.tcp_synack_retries=3" &gt;&gt; /etc/sysctl.conf
echo "# burst connection rate" &gt;&gt; /etc/sysctl.conf
echo "net.core.somaxconn=40000" &gt;&gt; /etc/sysctl.conf
echo "# how long to keep sockets in fin-wait-2" &gt;&gt; /etc/sysctl.conf
echo "net.ipv4.tcp_fin_timeout=5" &gt;&gt; /etc/sysctl.conf
sysctl -p
</pre>
<h4>ZFS</h4>
<p>Now before we forget let's go ahead and install NTP on our server to keep time in sync as well.</p>
<pre>sudo apt-get install ntp</pre>
<p>We now need to build our ZFS storage pool and create some datasets.<br />
So let's assume that you have 2-2TB drives you want to use for your ZFS pool initially (I will be showing a ZPOOL using 12-2TB disks). We can always grow the pool on the fly as we go forward. (**Note - If you are using Advanced Format drives with 4K blocks instead of 512 bytes..Green drives and a lot of newer non-green drives use 4K blocks...we will setup our pool in advance to accommodate for this from the beginning as the option is only available upon creation of the ZPOOL (ashift=12).)<br />
But first we need to install ZFS on our Ubuntu 14.04LTS server (ZOL = ZFS on Linux).<br />
Add the PPA for ZFS</p>
<pre>sudo apt-get install python-software-properties
sudo apt-add-repository ppa:zfs-native/stable
sudo apt-get update
sudo apt-get install ubuntu-zfs</pre>
<p>So now before we go too much further let's get some initial tweaks out of the way that specifically deal with SATA drives and memory.<br />
If you are only using SATA drives for your ZPOOL we need to limit the number of pending requests to these drives from ZFS to minimize disk time wait and etc. And we do that by creating and adding the following to /etc/modprobe.d/zfs.conf and a reboot is in order before these settings are active as well (You can also do this without a reboot by echoing these settings to the respective files in /sys/module/zfs/parameters folder, but let's not go into that for now).</p>
<pre>sudo nano /etc/modprobe.d/zfs.conf</pre>
<p>Add the following</p>
<pre># My tweaks for ZFS Performance
options zfs zfs_prefetch_disable=1
options zfs zfs_txg_timeout=5
options zfs zfs_vdev_async_write_max_active=1
options zfs zfs_vdev_async_write_min_active=1
options zfs zfs_vdev_async_read_max_active=1
options zfs zfs_vdev_async_read_min_active=1
options zfs zfs_vdev_sync_write_max_active=1
options zfs zfs_vdev_sync_write_min_active=1
options zfs zfs_vdev_sync_read_min_active=1
options zfs zfs_vdev_sync_read_max_active=1
</pre>
<p>Do not close and save this file yet until we do our memory tuning.<br />
Now let's touch on memory here. ZFS is memory hungry and the more memory you add to your server the better your performance will be. But we want to make sure that we don't starve the system for memory so we will limit the ZFS_ARC_MAX by allocating only 50% of our installed memory to begin with (You will want to tune this as you go forward). In this example I have 16GB installed in my server so I am going to limit ZFS_ARC_MAX to 8GB. We need to add this in bytes.<br />
For 8GB I would add the following to the still open /etc/modprobe.d/zfs.conf. You can always tweak this up as you start to see how things perform.</p>
<pre>#### Memory tuning - entered in bytes
# zfs_zrc_max (1/2 or 3/4 of system memory)
options zfs zfs_arc_max=8589934592
# zfs zfs_arc_meta_limit (1/4 of zfs_arc_max)
options zfs zfs_arc_meta_limit=2147483648
# zfs_arc_min (1/2 of zfs_arc_meta_limit)
options zfs zfs_arc_min=1073741824
</pre>
<p>Now save and close this file and go ahead and reboot your server.</p>
<p>If you want to adjust these settings on the fly you can do the following.</p>
<pre>sudo bash
echo 1073741824 &gt; /sys/module/zfs/parameters/zfs_arc_min
echo 8589934592 &gt; /sys/module/zfs/parameters/zfs_arc_max
echo 2147483648 &gt; /sys/module/zfs/parameters/zfs_arc_meta_limit
</pre>
<p>To see what the arcstats are currently set to run the following.</p>
<pre>cat /proc/spl/kstat/zfs/arcstats</pre>
<p>Example output of mine.</p>
<pre>root@nas02:/sys/module/zfs/parameters# cat /proc/spl/kstat/zfs/arcstats
5 1 0x01 85 4080 28525565526 7155039732857
name                            type data
hits                            4    1571965
misses                          4    19791
demand_data_hits                4    34847
demand_data_misses              4    297
demand_metadata_hits            4    1537093
demand_metadata_misses          4    19450
prefetch_data_hits              4    0
prefetch_data_misses            4    0
prefetch_metadata_hits          4    25
prefetch_metadata_misses        4    44
mru_hits                        4    35969
mru_ghost_hits                  4    291
mfu_hits                        4    1535989
mfu_ghost_hits                  4    16313
deleted                         4    668
recycle_miss                    4    0
mutex_miss                      4    0
evict_skip                      4    0
evict_l2_cached                 4    0
evict_l2_eligible               4    0
evict_l2_ineligible             4    4096
hash_elements                   4    34010
hash_elements_max               4    34012
hash_collisions                 4    11197
hash_chains                     4    1985
hash_chain_max                  4    3
p                               4    2095867904
c                               4    8589934592
<strong>c_min                           4    1073741824</strong>
<strong>c_max                           4    8589934592</strong>
size                            4    50592752
hdr_size                        4    10285680
data_size                       4    4342272
meta_size                       4    30484480
other_size                      4    4164200
anon_size                       4    425984
anon_evict_data                 4    0
anon_evict_metadata             4    0
mru_size                        4    17643008
mru_evict_data                  4    2562560
mru_evict_metadata              4    8500224
mru_ghost_size                  4    133391360
mru_ghost_evict_data            4    5120
mru_ghost_evict_metadata        4    133386240
mfu_size                        4    16757760
mfu_evict_data                  4    1763328
mfu_evict_metadata              4    14265344
mfu_ghost_size                  4    11125248
mfu_ghost_evict_data            4    512
mfu_ghost_evict_metadata        4    11124736
l2_hits                         4    20
l2_misses                       4    19729
l2_feeds                        4    7112
l2_rw_clash                     4    0
l2_read_bytes                   4    6656
l2_write_bytes                  4    97245696
l2_writes_sent                  4    1449
l2_writes_done                  4    1449
l2_writes_error                 4    0
l2_writes_hdr_miss              4    0
l2_evict_lock_retry             4    0
l2_evict_reading                4    0
l2_free_on_write                4    46
l2_abort_lowmem                 4    0
l2_cksum_bad                    4    0
l2_io_error                     4    0
l2_size                         4    160479232
l2_asize                        4    83066880
l2_hdr_size                     4    1316120
l2_compress_successes           4    41190
l2_compress_zeros               4    131
l2_compress_failures            4    838
memory_throttle_count           4    0
duplicate_buffers               4    0
duplicate_buffers_size          4    0
duplicate_reads                 4    0
memory_direct_count             4    0
memory_indirect_count           4    0
arc_no_grow                     4    0
arc_tempreserve                 4    0
arc_loaned_bytes                4    0
arc_prune                       4    0
arc_meta_used                   4    46250480
<strong>arc_meta_limit                  4    2147483648</strong>
arc_meta_max                    4    46255392
</pre>
<p>Now that your server is back online let's go ahead and create our ZPOOL.</p>
<p>Assuming you have SDA and SDB as your 2-TB drives we will create our pool as the following.</p>
<pre>sudo zpool create -o ashift=12 HD-Pool mirror sda sdb</pre>
<p>Before we go further we really want to get away from using sda, sdb and etc. for our ZPOOL and use either disk-id or WWN naming as our sd naming can change between reboots and etc. This can be done upon creating of the ZPOOL but you can also change this after creating the ZPOOL by doing the following.</p>
<pre>sudo zpool export HD-POOL
sudo zpool import -d /dev/disk/by-id HD-POOL
</pre>
<p>Now we are ready to create our ZFS Datasets. I like organization in doing this so I will be creating the following datasets (vmware and veeam) along with datasets for NFS and iSCSI for the vmware dataset.</p>
<pre>sudo zfs create -p HD-Pool/vmware/NFS
sudo zfs create HD-Pool/vmware/iSCSI
</pre>
<p>To validate that our datasets have been created</p>
<pre>sudo zfs list</pre>
<h4><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-10.03.56-AM.png"><img class="alignnone size-medium wp-image-3882" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-10.03.56-AM-300x77.png" alt="Screen Shot 2014-12-15 at 10.03.56 AM" width="300" height="77" /></a></h4>
<p>A few more tweaks we should make for our NFS access for vSphere is disabling atime and setting sync=disabled. Without sync=disabled for NFS your performance will be terrible. Setting sync=disabled disables ZIL (ZFS Intent Logging). Doing this is not always recommended but it will increase your NFS performance and data corruption will not occur. By default ZIL is written across all of your VDEVS but SSD drives can be added as logging devices to increase performance. One final tweak to adjust below is the default recordsize (128K) to 16K for our NFS dataset for vSphere. You will want to test this for your environment though either 8K-16K or default 128K. I find that 16K seems to be the sweet spot for my environment. And finally enable compression for the entire ZPOOL.</p>
<pre>zfs set sync=disabled HD-Pool/vmware/NFS
zfs set atime=off HD-Pool/vmware/NFS
zfs set recordsize=16K HD-Pool/vmware/NFS
zfs set compression=lz4 HD-Pool
</pre>
<p class="p1">This is where organization for your datasets makes life much easier because we can set different options based on our needs/requirements.</p>
<p>So now let's create a few more datasets for our NFS dataset in preparation of setting different options or quotas.</p>
<pre>sudo zfs create HD-Pool/vmware/NFS/tier_1
sudo zfs create HD-Pool/vmware/NFS/tier_2
sudo zfs create HD-Pool/vmware/NFS/tier_3
</pre>
<p>And if we do another zfs list to show our datasets we will see something similar to below.</p>
<pre>sudo zfs list</pre>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-10.16.37-AM.png"><img class="alignnone size-medium wp-image-3885" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-10.16.37-AM-300x90.png" alt="Screen Shot 2014-12-15 at 10.16.37 AM" width="300" height="90" /></a></p>
<p>So now that we have those new datasets created; by default they will inherit the settings that we have added to the HD-Pool/vmware/NFS dataset; which at this point is disabling atime and sync.</p>
<p>Pretty cool isn't it? :)</p>
<h4>NFS</h4>
<p>For NFS access we will be using the nfs-kernel-server package for Ubuntu and exporting our NFS mounts using ZFS.<br />
So let's install our NFS Server.</p>
<pre>sudo apt-get install nfs-kernel-server</pre>
<p>And before we go any further let's increase our number of NFS servers from the default of 8 to 16. This will spawn additional NFSD processes to increase performance for more than just a few vSphere hosts.</p>
<pre>sudo nano /etc/default/nfs-kernel-server</pre>
<p>At the top change the following from 8<br />
# Number of servers to start up<br />
RPCNFSDCOUNT=8<br />
To 16<br />
# Number of servers to start up<br />
RPCNFSDCOUNT=16<br />
Save and exit.<br />
Now we need to add one more thing to our NFS server on Ubuntu for the NFS server to actual start. Without doing this the NFS server will not start. You can change this to any mountpoint on your server. All it is doing is creating a dummy export to get the server to start. In this case we are exporting /mnt on localhost with read-only permissions.</p>
<pre>sudo nano /etc/exports</pre>
<p>And paste the following</p>
<pre>/mnt	localhost (ro)</pre>
<p>Now save, exit and start the NFS server.</p>
<pre>sudo service nfs-kernel-server start</pre>
<p>You will see the following error message but it can be safely ignored.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-10.33.56-AM.png"><img class="alignnone size-medium wp-image-3889" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-10.33.56-AM-300x82.png" alt="Screen Shot 2014-12-15 at 10.33.56 AM" width="300" height="82" /></a><br />
Now to validate that NFS is exporting run the following.</p>
<pre>sudo showmount -e</pre>
<p>You should see the following.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-11.07.16-AM.png"><img class="alignnone size-full wp-image-3897" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-11.07.16-AM.png" alt="Screen Shot 2014-12-15 at 11.07.16 AM" width="272" height="74" /></a><br />
Now it is time to begin exporting our ZFS datasets over NFS. One thing we need to do before we forget is to make sure that our NFS shares are exported upon boot-up is make the following change to /etc/default/zfs</p>
<pre>sudo nano /etc/default/zfs</pre>
<p>And change the following line</p>
<pre># Run `zfs share -a` during system start?
# nb: The shareiscsi, sharenfs, and sharesmb dataset properties.
<strong>ZFS_SHARE='no'</strong></pre>
<p>To</p>
<pre><strong>ZFS_SHARE='yes'</strong></pre>
<p>Now that is out of the way let's go ahead and export some of our ZFS datasets.<br />
First I want to limit the access to these exports to specific subnets which only require NFS mounts from our NAS. We will do this upon enabling NFS sharing for our datasets. In my case these subnets are 10.0.127.0/24 and 10.0.128.0/24.</p>
<pre>sudo zfs set sharenfs='rw=@10.0.127.0/24,rw=@10.0.128.0/24,no_root_squash,no_all_squash' HD-Pool/vmware/NFS/tier_1
sudo zfs set sharenfs='rw=@10.0.127.0/24,rw=@10.0.128.0/24,no_root_squash,no_all_squash' HD-Pool/vmware/NFS/tier_2
sudo zfs set sharenfs='rw=@10.0.127.0/24,rw=@10.0.128.0/24,no_root_squash,no_all_squash' HD-Pool/vmware/NFS/tier_3</pre>
<p>Now let's validate that our datasets are exports to the NFS server.</p>
<pre>showmount -e</pre>
<p>And you should see the following.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-11.24.42-AM.png"><img class="alignnone size-medium wp-image-3901" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-11.24.42-AM-300x81.png" alt="Screen Shot 2014-12-15 at 11.24.42 AM" width="300" height="81" /></a><br />
That's it for NFS. You should be able to mount up your respective NFS datastores from your vSphere hosts now at this point.</p>
<p>One additional important note here. If for some reason you restart or reload the nfs-kernel-server service you WILL lose access to your NFS mountpoints (Not a good thing). So if you do restart or reload the service you will need to run the following as well.</p>
<pre>sudo zfs share -a</pre>
<p>Or you can create shell scripts for restarting or reloading the NFS server.</p>
<pre>nano reload_nfs.sh
#!/bin/bash
service nfs-kernel-server reload
zfs share -a
</pre>
<pre>chmod +x reload_nfs.sh</pre>
<pre>nano restart_nfs.sh
#!/bin/bash
service nfs-kernel-server restart
zfs share -a</pre>
<pre>chmod +x restart_nfs.sh</pre>
<p>Now to run them execute the following<br />
To reload</p>
<pre>sudo reload_nfs.sh</pre>
<p>To restart</p>
<pre>sudo restart_nfs.sh</pre>
<h4>iSCSI</h4>
<p>We will be using <a title="http://linux-iscsi.org/wiki/Main_Page" href="http://linux-iscsi.org/wiki/Main_Page" target="_blank">LIO</a> (Linux-IO Target). This iSCSI target implementation is kernel based and supports many <a title="http://linux-iscsi.org/wiki/VStorage_APIs_for_Array_Integration" href="http://linux-iscsi.org/wiki/VStorage_APIs_for_Array_Integration" target="_blank">VAAI</a> primitives for vSphere, which is what I want.</p>
<pre>sudo apt-get install lio-utils
sudo apt-get install --no-install-recommends targetcli python-urwid</pre>
<p>First we will create a block device to use for our iSCSI target device. (The -s tells it to create a sparse volume "thin")</p>
<pre>sudo zfs create -sp -V 100GB HD-Pool/vmware/iSCSI/datastore_1</pre>
<p>Now if we list our ZFS datasets we should have the following.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-11.40.11-AM.png"><img class="alignnone size-medium wp-image-3909" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-11.40.11-AM-300x89.png" alt="Screen Shot 2014-12-15 at 11.40.11 AM" width="300" height="89" /></a></p>
<p>Now if you do an sudo fdisk -l we can see that a new block device has been created.</p>
<pre>sudo fdisk -l</pre>
<p>This created a new block device at /dev/zd0 that we can use for our iSCSI target setup.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-11.42.30-AM.png"><img class="alignnone size-medium wp-image-3910" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-11.42.30-AM-300x75.png" alt="Screen Shot 2014-12-15 at 11.42.30 AM" width="300" height="75" /></a></p>
<p>Now we will setup iSCSI so we can present storage to our vSphere hosts.</p>
<pre>sudo targetcli</pre>
<p>We are now within the configuration utility to start creating our iSCSI targets and volumes.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-2.03.32-PM.png"><img class="alignnone size-medium wp-image-3830" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-2.03.32-PM-300x75.png" alt="Screen Shot 2014-12-14 at 2.03.32 PM" width="300" height="75" /></a></p>
<p>If you type</p>
<pre>ls</pre>
<p>you will get a listing of each type of configuration we can setup.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-2.03.46-PM.png"><img class="alignnone size-medium wp-image-3833" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-2.03.46-PM-300x68.png" alt="Screen Shot 2014-12-14 at 2.03.46 PM" width="300" height="68" /></a><br />
Let's first setup our new ZVOL as an iblock.</p>
<pre>backstores/iblock create name=hd-pool_vmware_datastore_1 dev=/dev/zd0</pre>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-2.15.53-PM.png"><img class="alignnone size-medium wp-image-3834" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-2.15.53-PM-300x34.png" alt="Screen Shot 2014-12-14 at 2.15.53 PM" width="300" height="34" /></a></p>
<p class="p1"><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-2.16.47-PM.png"><img class="alignnone size-medium wp-image-3838" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-2.16.47-PM-300x73.png" alt="Screen Shot 2014-12-14 at 2.16.47 PM" width="300" height="73" /></a></p>
<p class="p1">Now let's create our iSCSI Target (TPG)</p>
<pre>iscsi/ create</pre>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-2.28.37-PM.png"><img class="alignnone size-medium wp-image-3842" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-2.28.37-PM-300x36.png" alt="Screen Shot 2014-12-14 at 2.28.37 PM" width="300" height="36" /></a></p>
<p>And let's create another one seeing as we have two IP addresses assigned (One on VLAN129 and the other on VLAN130)</p>
<pre>iscsi/ create</pre>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-2.43.33-PM.png"><img class="alignnone size-medium wp-image-3846" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-2.43.33-PM-300x120.png" alt="Screen Shot 2014-12-14 at 2.43.33 PM" width="300" height="120" /></a></p>
<p>&nbsp;</p>
<p>Now let's attach our ZVOL (ssd-pool_vmware_datastore_1 (/dev/zd0)) to our TPGS</p>
<pre>iscsi/iqn.2003-01.org.linux-iscsi.nas01.x8664:sn.65e50d149946/tpgt1/luns create /backstores/iblock/hd-pool_vmware_datastore_1
iscsi/iqn.2003-01.org.linux-iscsi.nas01.x8664:sn.8091c98a173d/tpgt1/luns create /backstores/iblock/hd-pool_vmware_datastore_1
</pre>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-3.01.52-PM.png"><img class="alignnone size-medium wp-image-3849" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-3.01.52-PM-300x122.png" alt="Screen Shot 2014-12-14 at 3.01.52 PM" width="300" height="122" /></a></p>
<p>Now we need to assign an IP interface to each portal group for each TPG that we created above.</p>
<pre>iscsi/iqn.2003-01.org.linux-iscsi.nas01.x8664:sn.65e50d149946/tpgt1/portals create 10.0.129.50
iscsi/iqn.2003-01.org.linux-iscsi.nas01.x8664:sn.8091c98a173d/tpgt1/portals create 10.0.130.50
</pre>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-3.40.25-PM.png"><img class="alignnone size-medium wp-image-3854" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-3.40.25-PM-300x138.png" alt="Screen Shot 2014-12-14 at 3.40.25 PM" width="300" height="138" /></a></p>
<p>Now we are going to allow acess to our luns without authentication but we will use ACLs to assign our initiators to and control access that way. You may want to do differently but for this setup it is fine.</p>
<pre>iscsi/iqn.2003-01.org.linux-iscsi.nas01.x8664:sn.65e50d149946/tpgt1 set attribute authentication=0
iscsi/iqn.2003-01.org.linux-iscsi.nas01.x8664:sn.8091c98a173d/tpgt1 set attribute authentication=0
</pre>
<p>And now we will assign each of our vSphere hosts iSCSI initiator names to our ACLs for each TPG so our hosts will see our new iSCSI lun.</p>
<pre>iscsi/iqn.2003-01.org.linux-iscsi.nas01.x8664:sn.65e50d149946/tpgt1/acls create wwn=iqn.1998-01.com.vmware:esxi01-7685c3a8
iscsi/iqn.2003-01.org.linux-iscsi.nas01.x8664:sn.8091c98a173d/tpgt1/acls create wwn=iqn.1998-01.com.vmware:esxi01-7685c3a8
</pre>
<p>Now after adding all of your hosts to the ACLs for each TPG your setup should look similar to below.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-3.52.12-PM.png"><img class="alignnone size-medium wp-image-3857" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-3.52.12-PM-300x196.png" alt="Screen Shot 2014-12-14 at 3.52.12 PM" width="300" height="196" /></a></p>
<p>Now make sure to save your new configuration setup to make sure this persists between reboots. Type "saveconfig"</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-14-at-3.55.01-PM.png"><img class="alignnone size-medium wp-image-3858" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-14-at-3.55.01-PM-300x131.png" alt="Screen Shot 2014-12-14 at 3.55.01 PM" width="300" height="131" /></a></p>
<p>And after your rescan all of your hosts you should see a new disk target available.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Untitled.png"><img class="alignnone size-medium wp-image-3862" src="{{ site.baseurl }}/assets/Untitled-300x170.png" alt="Untitled" width="300" height="170" /></a></p>
<p>&nbsp;</p>
<p>That's it for our iSCSI setup.</p>
<h4>Samba (SMB/CIFS)</h4>
<p>Now of course a general purpose NAS would not be complete without adding Windows file sharing support would it? :) In my case I am only setting up a generic Samba share to use for Veeam backups. So that is what I will be doing here.</p>
<p>First thing is to create a unix username called veeam and create a password.</p>
<pre>sudo adduser veeam</pre>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-1.03.19-PM.png"><img class="alignnone size-medium wp-image-3926" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-1.03.19-PM-300x207.png" alt="Screen Shot 2014-12-15 at 1.03.19 PM" width="300" height="207" /></a></p>
<p>Now let's install samba (ZOL utilizes the native  Linux samba package).</p>
<pre>sudo apt-get install samba</pre>
<p>Once that is complete I want to share out my veeam_backups dataset.</p>
<p>Now we need to create the dataset with some parameters up front because one of them cannot be changed after being created (casesensitivity). And nbmand=on (Non Blocking Mandatory Locks) for CIFS clients.</p>
<pre>sudo zfs create -o casesensitivity=mixed -o nbmand=on HD-Pool/veeam/veeam_backups</pre>
<p>So now we have created the dataset for Windows sharing we need to actually share it out.</p>
<pre>sudo zfs set sharesmb=on HD-Pool/veeam/veeam_backups</pre>
<p>Now create your veeam samba user/password. Match to the same password that you created for the actual UNIX account.</p>
<pre>sudo smbpasswd -a veeam</pre>
<p>Now if you browse to the NAS name you should see the share and when you double click on it; enter username/password created from above. You have read access only to this share at this point however.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-1.35.36-PM.png"><img class="alignnone size-medium wp-image-3930" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-1.35.36-PM-300x119.png" alt="Screen Shot 2014-12-15 at 1.35.36 PM" width="300" height="119" /></a></p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-1.37.46-PM.png"><img class="alignnone size-medium wp-image-3933" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-1.37.46-PM-300x237.png" alt="Screen Shot 2014-12-15 at 1.37.46 PM" width="300" height="237" /></a></p>
<p>Try creating a new folder and you will get access denied.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-1.38.35-PM.png"><img class="alignnone size-medium wp-image-3934" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-1.38.35-PM-300x200.png" alt="Screen Shot 2014-12-15 at 1.38.35 PM" width="300" height="200" /></a></p>
<p>Now it appears that Samba sharing with ZOL is very kludgy and not as tight as on Solaris so for now I am going to do the following for my veeam user to be allowed to write to this share.<br />
We will grant full access to the veeam group leaving root as the owner. You will want to modify this based on your needs for owner/group.</p>
<pre>sudo chown root:veeam /HD-Pool/veeam/veeam_backups
sudo chmod 0775 /HD-Pool/veeam/veeam_backups</pre>
<p>I really don't like the above but for now it works just fine as I only have one user connecting.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-2.57.18-PM.png"><img class="alignnone size-medium wp-image-3938" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-2.57.18-PM-300x120.png" alt="Screen Shot 2014-12-15 at 2.57.18 PM" width="300" height="120" /></a></p>
<h4>Security</h4>
<p>One last thing I want to touch on here is locking down NFS access. I know we allowed RW access from 10.0.127.0/24 and 10.0.128.0/24 a ways up but here is what you will see from another computer on your network accessing the NAS from the 10.0.101.0/24 address.</p>
<p>If I run a showmount -e nas02 from my OSX computer.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-3.00.32-PM.png"><img class="alignnone size-medium wp-image-3942" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-3.00.32-PM-300x79.png" alt="Screen Shot 2014-12-15 at 3.00.32 PM" width="300" height="79" /></a></p>
<p>So with IPTables we will lock this down coming in from the vlan101 interface.</p>
<pre>sudo iptables -A INPUT -i vlan101 -p tcp --dport 111 -j DROP
sudo iptables -A INPUT -i vlan101 -p udp --dport 111 -j DROP
sudo iptables -A INPUT -i vlan101 -p tcp --dport 2049 -j DROP
sudo iptables -A INPUT -i vlan101 -p udp --dport 2049 -j DROP
</pre>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-3.07.33-PM.png"><img class="alignnone size-medium wp-image-3945" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-3.07.33-PM-300x106.png" alt="Screen Shot 2014-12-15 at 3.07.33 PM" width="300" height="106" /></a></p>
<p>And now if I do a showmount -e nas02 from my OSX computer.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-3.08.36-PM.png"><img class="alignnone size-medium wp-image-3946" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-3.08.36-PM-300x25.png" alt="Screen Shot 2014-12-15 at 3.08.36 PM" width="300" height="25" /></a></p>
<p>And if I look at my IPTables rules on nas02.</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-3.11.30-PM.png"><img class="alignnone size-medium wp-image-3949" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-3.11.30-PM-300x87.png" alt="Screen Shot 2014-12-15 at 3.11.30 PM" width="300" height="87" /></a></p>
<p>&nbsp;</p>
<p>Now to make these IPTables rules stick across reboots we will install iptables-persistent.</p>
<pre>sudo apt-get install iptables-persistent</pre>
<p>Say "yes"</p>
<p><a href="http://everythingshouldbevirtual.com/wp-content/uploads/2014/12/Screen-Shot-2014-12-15-at-3.25.02-PM.png"><img class="alignnone size-medium wp-image-3954" src="{{ site.baseurl }}/assets/Screen-Shot-2014-12-15-at-3.25.02-PM-300x100.png" alt="Screen Shot 2014-12-15 at 3.25.02 PM" width="300" height="100" /></a></p>
<p>Keep in mind that this will save the existing rules but if you make changes you will need to run the following.</p>
<pre>sudo iptables-save</pre>
<p>So there you have it. We have now successfully built our homebrew NAS for our vSphere environment. I am seeing sub 10ms latency (average) on this setup running about 60 VMs on it over NFS. I will be posting some testing results here shortly to show some IOMeter testing between NFS and iSCSI.</p>
<p>Enjoy!</p>
